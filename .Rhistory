library(fsn)
library(fsn)
MXM::MMPC
library(fsn)
library(fsn)
qn
R = 1000
alpha = 0.05
ncol = 100
a = seq( 10, 5000, by = 10)
a <- matrix( a, ncol = ncol )
k <- a
R <- R
mat <- as.numeric(R)
qn2 <- qnorm(1 - alpha)^2
for (j in 1:100) {
for ( i in 1:5 ) {
for (l in 1:R) {
z <- Rfast::Rnorm(k[i, j])
mat[l] <- sum( abs(z) )^2 / qn2
}
a[i, j] <- mean(mat)
}
}
e <- k * (2 * k + pi -2) / ( pi * qn2 )
y1 <- as.vector( abs(e - a) / a )
k1 <- as.vector(k)
plot(k1, y1, type = 'l', ylab = 'Absolute relative error', xlab = 'Number of studies', cex.lab = 1.2, cex.axis = 1.2)
y2 <- log(y1)
x2 <- log(k1)
dev.new()
plot(x2, y2, type = 'l', ylab = 'Logarithm of absolute relative error',
xlab = 'Logarithm of the number of studies', cex.lab = 1.2, cex.axis = 1.2)
lm(y2~x2)
mod <- lm(y2 ~ x2)
mod$coefficients[1]
y1 <- as.vector( abs(e - a) / a )
k1 <- as.vector(k)
plot(k1, y1, type = 'l', ylab = 'Absolute relative error', xlab = 'Number of studies', cex.lab = 1.2, cex.axis = 1.2)
y2 <- log(y1)
x2 <- log(k1)
dev.new()
plot(x2, y2, type = 'l', ylab = 'Logarithm of absolute relative error',
xlab = 'Logarithm of the number of studies', cex.lab = 1.2, cex.axis = 1.2)
mod <- lm(y2 ~ x2)
abline(a = mod$coefficients[1], b = mod$coefficients[1], col = 2, lty = 2, lwd = 3)
mod$coefficients
abline(a = mod$coefficients[1], b = mod$coefficients[1], col = 2, lty = 2, lwd = 3)
y1 <- as.vector( abs(e - a) / a )
k1 <- as.vector(k)
plot(k1, y1, type = 'l', ylab = 'Absolute relative error', xlab = 'Number of studies', cex.lab = 1.2, cex.axis = 1.2)
y2 <- log(y1)
x2 <- log(k1)
dev.new()
plot(x2, y2, type = 'l', ylab = 'Logarithm of absolute relative error',
xlab = 'Logarithm of the number of studies', cex.lab = 1.2, cex.axis = 1.2)
mod <- lm(y2 ~ x2)
abline(a = mod$coefficients[1], b = mod$coefficients[2], col = 2, lty = 2, lwd = 3)
k = seq( 10, 5000, by = 10)
k <- matrix( a, ncol = ncol )
k
ncol
k = seq( 10, 5000, by = 10)
k <- matrix( k, ncol = ncol )
k
k[i,j]
i=1
j=1
k[i,j]
R=100
k <- matrix( k, ncol = ncol )
a <- k
R <- R
mat <- as.numeric(R)
qn2 <- qnorm(1 - alpha)^2
for (j in 1:100) {
for ( i in 1:5 ) {
for (l in 1:R) {
z <- Rfast::Rnorm(k[i, j])
mat[l] <- sum( abs(z) )^2 / qn2
}
a[i, j] <- mean(mat)
}
}
a
a <- k
R <- R
mat <- as.numeric(R)
qn2 <- qnorm(1 - alpha)^2
for ( i in 1:length(k) ) {
for (j in 1:R) {
z <- Rfast::Rnorm(k[i])
mat[j] <- sum( abs(z) )^2 / qn2
}
a[i] <- mean(mat)
}
e <- k * (2 * k + pi -2) / ( pi * qn2 )
y1 <- as.vector( abs(e - a) / a )
k1 <- as.vector(k)
plot(k1, y1, type = 'l', ylab = 'Absolute relative error', xlab = 'Number of studies', cex.lab = 1.2, cex.axis = 1.2)
y2 <- log(y1)
x2 <- log(k1)
dev.new()
plot(x2, y2, type = 'l', ylab = 'Logarithm of absolute relative error',
xlab = 'Logarithm of the number of studies', cex.lab = 1.2, cex.axis = 1.2)
mod <- lm(y2 ~ x2)
abline(a = mod$coefficients[1], b = mod$coefficients[2], col = 2, lty = 2, lwd = 3)
mod$coefficients
# k <- matrix( k, ncol = ncol )
a <- k
R <- R
mat <- as.numeric(R)
qn2 <- qnorm(1 - alpha)^2
for ( i in 1:length(k) ) {
for (j in 1:R) {
z <- abs( Rfast::Rnorm(k[i]) )
mat[j] <- sum(z)^2 / qn2
}
a[i] <- mean(mat)
}
e <- k * (2 * k + pi -2) / ( pi * qn2 )
y1 <- as.vector( abs(e - a) / a )
k1 <- as.vector(k)
plot(k1, y1, type = 'l', ylab = 'Absolute relative error', xlab = 'Number of studies', cex.lab = 1.2, cex.axis = 1.2)
y2 <- log(y1)
x2 <- log(k1)
dev.new()
plot(x2, y2, type = 'l', ylab = 'Logarithm of absolute relative error',
xlab = 'Logarithm of the number of studies', cex.lab = 1.2, cex.axis = 1.2)
mod <- lm(y2 ~ x2)
abline(a = mod$coefficients[1], b = mod$coefficients[2], col = 2, lty = 2, lwd = 3)
mod$coefficients
library(fsn)
library(grDevices)
?dev.new
f
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
source('C:/Users/user/Desktop/Folder/paketo/fsn/R/halfnorm.fixednr.ci.R')
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
library(fsn)
k = seq( 10, 5000, by = 10)
R = 1000
k = seq( 50, 500, by = 50)
k
R = 1000
alpha = 0.05
a <- k
mat <- as.numeric(R)
qn2 <- qnorm(1 - alpha)^2
for (j in 1:R) {
z <- abs( Rfast::Rnorm(k[i]) )
mat[j] <- sum(z)^2 / qn2
}
i=1
for ( i in 1:length(k) ) {
for (j in 1:R) {
z <- abs( Rfast::Rnorm(k[i]) )
mat[j] <- sum(z)^2 / qn2
}
a[i] <- mean(mat)
}
a
for ( i in 1:length(k) ) {
z <- abs( Rfast::matrnorm(k[i], R) )
mat <- Rfast::colsums(z)^2 / qn2
a[i] <- mean(mat)
}
a
z <- abs( Rfast::matrnorm(k[i], R) )
mat <- Rfast::colsums(z)^2 / qn2
mean(mat)
mean(sum(z)^2)/qn2
mean(z)^2)/qn2
mean(z)^2/qn2
library(fsn)
Rfast::lmfit
